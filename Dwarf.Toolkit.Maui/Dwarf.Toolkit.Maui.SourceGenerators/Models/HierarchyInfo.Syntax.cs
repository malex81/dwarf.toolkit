using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Collections.Immutable;

namespace Dwarf.Toolkit.Maui.SourceGenerators.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

partial record HierarchyInfo
{
	/// <summary>
	/// Creates a <see cref="CompilationUnitSyntax"/> instance wrapping the given members.
	/// </summary>
	/// <param name="memberDeclarations">The input <see cref="MemberDeclarationSyntax"/> instances to use.</param>
	/// <param name="baseList">The optional <see cref="BaseListSyntax"/> instance to add to generated types.</param>
	/// <returns>A <see cref="CompilationUnitSyntax"/> object wrapping <paramref name="memberDeclarations"/>.</returns>
	public CompilationUnitSyntax GetCompilationUnit(
		ImmutableArray<MemberDeclarationSyntax> memberDeclarations,
		BaseListSyntax? baseList = null)
	{
		// Create the partial type declaration with the given member declarations.
		// This code produces a class declaration as follows:
		//
		// /// <inheritdoc/>
		// partial <TYPE_KIND> TYPE_NAME>
		// {
		//     <MEMBERS>
		// }
		TypeDeclarationSyntax typeDeclarationSyntax =
			Hierarchy[0].GetSyntax()
			.AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
			.AddMembers(memberDeclarations.ToArray());

		// Add the base list, if present
		if (baseList is not null)
		{
			typeDeclarationSyntax = typeDeclarationSyntax.WithBaseList(baseList);
		}

		// Add all parent types in ascending order, if any
		foreach (TypeInfo parentType in Hierarchy.AsSpan()[1..])
		{
			typeDeclarationSyntax =
				parentType.GetSyntax()
						.AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
						.AddMembers(typeDeclarationSyntax);
		}

		// Prepare the leading trivia for the generated compilation unit.
		// This will produce code as follows:
		//
		// <auto-generated/>
		// #pragma warning disable
		// #nullable enable
		SyntaxTriviaList syntaxTriviaList = TriviaList(
			Comment("// <auto-generated/>"),
			Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
			Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));

		if (Namespace is "")
		{
			// Special case for top level types with no namespace: we need to re-add the
			// inheritdoc XML comment, as otherwise the call below would remove it.
			syntaxTriviaList = syntaxTriviaList.Add(Comment("/// <inheritdoc/>"));

			// If there is no namespace, attach the pragma directly to the declared type,
			// and skip the namespace declaration. This will produce code as follows:
			//
			// <SYNTAX_TRIVIA>
			// <TYPE_HIERARCHY>
			return CompilationUnit()
				.AddMembers(typeDeclarationSyntax.WithLeadingTrivia(syntaxTriviaList))
				.NormalizeWhitespace(indentation: "\t");
		}

		// Create the compilation unit with disabled warnings, target namespace and generated type.
		// This will produce code as follows:
		//
		// <SYNTAX_TRIVIA>
		// namespace <NAMESPACE>
		// {
		//     <TYPE_HIERARCHY>
		// }
		return CompilationUnit()
			//.AddMembers(NamespaceDeclaration(IdentifierName(Namespace))
			.AddMembers(FileScopedNamespaceDeclaration(IdentifierName(Namespace))
			.WithLeadingTrivia(syntaxTriviaList)
			.AddMembers(typeDeclarationSyntax))
			.NormalizeWhitespace(indentation: "\t");
	}
}